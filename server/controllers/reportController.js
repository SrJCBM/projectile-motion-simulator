/**
 * Report Controller
 * 
 * Handles PDF report generation for simulations
 * Uses pdfkit with careful ASCII-only text to avoid encoding issues
 */

const PDFDocument = require('pdfkit');

// Colors for the PDF theme
const COLORS = {
    primary: '#2a9d8f',
    secondary: '#264653',
    accent: '#e76f51',
    text: '#333333',
    textLight: '#666666',
    border: '#e0e0e0',
    background: '#f8f9fa',
    white: '#ffffff'
};

/**
 * Draws a rounded rectangle
 */
function drawRoundedRect(doc, x, y, width, height, radius, fillColor, strokeColor = null) {
    doc.save();
    doc.roundedRect(x, y, width, height, radius);
    if (fillColor) {
        doc.fillColor(fillColor).fill();
    }
    if (strokeColor) {
        doc.strokeColor(strokeColor).stroke();
    }
    doc.restore();
}

/**
 * Draws a section header with decorative line
 */
function drawSectionHeader(doc, title, yPos) {
    doc.fontSize(14)
       .fillColor(COLORS.secondary)
       .font('Helvetica-Bold')
       .text(title, 50, yPos);
    
    const textWidth = doc.widthOfString(title);
    doc.moveTo(50, yPos + 18)
       .lineTo(50 + textWidth + 10, yPos + 18)
       .lineWidth(2)
       .strokeColor(COLORS.primary)
       .stroke();
    
    return yPos + 30;
}

/**
 * Draws a parameter/result card
 */
function drawCard(doc, x, y, width, height, label, value, unit, iconType) {
    // Card background
    drawRoundedRect(doc, x, y, width, height, 8, COLORS.white);
    doc.roundedRect(x, y, width, height, 8)
       .strokeColor(COLORS.border)
       .lineWidth(1)
       .stroke();
    
    // Left accent bar
    doc.save();
    doc.rect(x, y + 8, 4, height - 16).fill(COLORS.primary);
    doc.restore();
    
    // Label
    doc.fontSize(9)
       .fillColor(COLORS.textLight)
       .font('Helvetica')
       .text(label, x + 15, y + 12, { width: width - 20 });
    
    // Value
    doc.fontSize(18)
       .fillColor(COLORS.secondary)
       .font('Helvetica-Bold')
       .text(value, x + 15, y + 28, { width: width - 20, continued: true });
    
    // Unit
    doc.fontSize(11)
       .fillColor(COLORS.textLight)
       .font('Helvetica')
       .text(` ${unit}`, { continued: false });
}

/**
 * @desc    Generate PDF report for a simulation
 * @route   POST /api/reports/generate
 * @access  Private
 */
const generateReport = async (req, res) => {
    try {
        const { params, results, lang = 'es', canvasImage } = req.body;
        
        // Validate required data
        if (!params || !results) {
            return res.status(400).json({
                success: false,
                message: 'Missing simulation data'
            });
        }
        
        // Localized labels
        const labels = {
            es: {
                title: 'Reporte de Simulacion',
                subtitle: 'Movimiento Proyectil',
                generated: 'Generado',
                inputParams: 'Parametros de Entrada',
                results: 'Resultados de la Simulacion',
                formulas: 'Formulas Fisicas Utilizadas',
                velocity: 'Velocidad Inicial',
                angle: 'Angulo de Lanzamiento',
                height: 'Altura Inicial',
                gravity: 'Gravedad',
                maxHeight: 'Altura Maxima',
                distance: 'Distancia Horizontal',
                flightTime: 'Tiempo de Vuelo',
                finalVelocity: 'Velocidad Final',
                trajectoryEq: 'Ecuacion de Trayectoria',
                positionEq: 'Posicion en el tiempo t',
                maxHeightEq: 'Altura Maxima',
                footer1: 'Generado por Projectile Motion Simulator',
                footer2: 'Para propositos educativos'
            },
            en: {
                title: 'Simulation Report',
                subtitle: 'Projectile Motion',
                generated: 'Generated',
                inputParams: 'Input Parameters',
                results: 'Simulation Results',
                formulas: 'Physics Formulas Used',
                velocity: 'Initial Velocity',
                angle: 'Launch Angle',
                height: 'Initial Height',
                gravity: 'Gravity',
                maxHeight: 'Maximum Height',
                distance: 'Horizontal Distance',
                flightTime: 'Flight Time',
                finalVelocity: 'Final Velocity',
                trajectoryEq: 'Trajectory Equation',
                positionEq: 'Position at time t',
                maxHeightEq: 'Maximum Height',
                footer1: 'Generated by Projectile Motion Simulator',
                footer2: 'For educational purposes'
            }
        };
        
        const t = labels[lang] || labels.es;
        
        // Create PDF document
        const doc = new PDFDocument({
            size: 'A4',
            margin: 50,
            info: {
                Title: 'Projectile Motion Simulation Report',
                Author: 'Projectile Motion Simulator',
                Subject: 'Physics Simulation Report'
            }
        });
        
        // Set response headers for PDF download
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', 'attachment; filename=simulation-report.pdf');
        
        // Pipe PDF to response
        doc.pipe(res);
        
        // === PDF Content ===
        
        // Header background
        drawRoundedRect(doc, 40, 40, 515, 90, 10, COLORS.secondary);
        
        // Title
        doc.fontSize(28)
           .fillColor(COLORS.white)
           .font('Helvetica-Bold')
           .text(t.title, 50, 55, { align: 'center', width: 495 });
        
        doc.fontSize(14)
           .fillColor(COLORS.primary)
           .font('Helvetica')
           .text(t.subtitle, 50, 90, { align: 'center', width: 495 });
        
        // Date
        const dateStr = new Date().toLocaleDateString(lang === 'en' ? 'en-US' : 'es-ES', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        doc.fontSize(10)
           .fillColor('#aaaaaa')
           .text(`${t.generated}: ${dateStr}`, 50, 110, { align: 'center', width: 495 });
        
        // Simulation Image Section (if provided)
        let yPos = 150;
        
        if (canvasImage && canvasImage.startsWith('data:image')) {
            const imgLabel = lang === 'en' ? 'Trajectory Visualization' : 'Visualizacion de Trayectoria';
            yPos = drawSectionHeader(doc, imgLabel, yPos);
            yPos += 5;
            
            try {
                // Convert base64 to buffer
                const base64Data = canvasImage.replace(/^data:image\/png;base64,/, '');
                const imgBuffer = Buffer.from(base64Data, 'base64');
                
                // Draw image with border
                const imgWidth = 495;
                const imgHeight = 200;
                
                drawRoundedRect(doc, 50, yPos, imgWidth, imgHeight + 10, 8, COLORS.white);
                doc.roundedRect(50, yPos, imgWidth, imgHeight + 10, 8)
                   .strokeColor(COLORS.border)
                   .lineWidth(1)
                   .stroke();
                
                doc.image(imgBuffer, 55, yPos + 5, {
                    fit: [imgWidth - 10, imgHeight],
                    align: 'center',
                    valign: 'center'
                });
                
                yPos += imgHeight + 25;
            } catch (imgError) {
                console.error('Error adding image to PDF:', imgError);
                // Continue without image
            }
        }
        
        // Input Parameters Section
        yPos = drawSectionHeader(doc, t.inputParams, yPos);
        yPos += 10;
        
        // Parameter cards (2x2 grid)
        const cardWidth = 240;
        const cardHeight = 55;
        const cardGap = 15;
        
        drawCard(doc, 50, yPos, cardWidth, cardHeight, 
                 `${t.velocity} (v0)`, params.initialVelocity.toString(), 'm/s');
        drawCard(doc, 50 + cardWidth + cardGap, yPos, cardWidth, cardHeight, 
                 `${t.angle} (0)`, params.launchAngle.toString(), 'grados');
        
        yPos += cardHeight + cardGap;
        
        drawCard(doc, 50, yPos, cardWidth, cardHeight, 
                 `${t.height} (h0)`, params.initialHeight.toString(), 'm');
        drawCard(doc, 50 + cardWidth + cardGap, yPos, cardWidth, cardHeight, 
                 `${t.gravity} (g)`, params.gravity.toString(), 'm/s2');
        
        // Results Section
        yPos += cardHeight + 40;
        yPos = drawSectionHeader(doc, t.results, yPos);
        yPos += 10;
        
        // Result cards (2x2 grid)
        drawCard(doc, 50, yPos, cardWidth, cardHeight, 
                 t.maxHeight, results.maxHeight.toFixed(2), 'm');
        drawCard(doc, 50 + cardWidth + cardGap, yPos, cardWidth, cardHeight, 
                 t.distance, results.range.toFixed(2), 'm');
        
        yPos += cardHeight + cardGap;
        
        drawCard(doc, 50, yPos, cardWidth, cardHeight, 
                 t.flightTime, results.flightTime.toFixed(2), 's');
        drawCard(doc, 50 + cardWidth + cardGap, yPos, cardWidth, cardHeight, 
                 t.finalVelocity, results.finalVelocity.toFixed(2), 'm/s');
        
        // Check if we need a new page for formulas
        if (yPos > 550) {
            doc.addPage();
            yPos = 50;
        }
        
        // Formulas Section
        yPos += cardHeight + 30;
        yPos = drawSectionHeader(doc, t.formulas, yPos);
        yPos += 10;
        
        // Formulas in a styled box
        const formulaBoxHeight = 120;
        drawRoundedRect(doc, 50, yPos, 495, formulaBoxHeight, 8, '#f8f9fa');
        doc.roundedRect(50, yPos, 495, formulaBoxHeight, 8)
           .strokeColor(COLORS.border)
           .lineWidth(1)
           .stroke();
        
        const formulaX = 70;
        let formulaY = yPos + 12;
        
        doc.fontSize(9)
           .fillColor(COLORS.secondary)
           .font('Helvetica-Bold')
           .text(t.trajectoryEq + ':', formulaX, formulaY);
        formulaY += 12;
        doc.font('Courier')
           .fontSize(8)
           .fillColor(COLORS.text)
           .text('y = x * tan(angle) - (g * x^2) / (2 * v0^2 * cos^2(angle))', formulaX + 15, formulaY);
        
        formulaY += 20;
        doc.font('Helvetica-Bold')
           .fontSize(9)
           .fillColor(COLORS.secondary)
           .text(t.positionEq + ':', formulaX, formulaY);
        formulaY += 12;
        doc.font('Courier')
           .fontSize(8)
           .fillColor(COLORS.text)
           .text('x(t) = v0 * cos(angle) * t    |    y(t) = h0 + v0 * sin(angle) * t - 0.5 * g * t^2', formulaX + 15, formulaY);
        
        formulaY += 20;
        doc.font('Helvetica-Bold')
           .fontSize(9)
           .fillColor(COLORS.secondary)
           .text(t.maxHeightEq + ':', formulaX, formulaY);
        formulaY += 12;
        doc.font('Courier')
           .fontSize(8)
           .fillColor(COLORS.text)
           .text('y_max = h0 + (v0^2 * sin^2(angle)) / (2 * g)', formulaX + 15, formulaY);
        
        // Footer
        const footerY = Math.max(yPos + formulaBoxHeight + 40, 780);
        doc.moveTo(50, footerY).lineTo(545, footerY).strokeColor(COLORS.border).lineWidth(1).stroke();
        
        doc.fontSize(9)
           .fillColor(COLORS.textLight)
           .font('Helvetica')
           .text(t.footer1, 50, footerY + 10, { align: 'center', width: 495 });
        doc.fontSize(8)
           .text(t.footer2, 50, footerY + 22, { align: 'center', width: 495 });
        
        // Finalize PDF
        doc.end();
        
    } catch (error) {
        console.error('Generate report error:', error);
        res.status(500).json({
            success: false,
            message: 'Error generating report'
        });
    }
};

module.exports = {
    generateReport
};
